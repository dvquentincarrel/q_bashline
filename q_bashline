#!/bin/bash

# Status line for bash
# Structure:
#     exit_code / nnn_depth / pwd / git-branch / git-status-infos

exit_code=$?

_exit=
_nnn=
_cwd=
QBL_SLEEP=${QBL_SLEEP:-0.02}
QBL_ASYNC=${QBL_ASYNC:-true} # Asynchronous by default
GIT_REV=
REPO_INFO= # Remove if you don't want to reset output between each command

# Displays error message ONCE, after the coproc died
if [[ -z $CO_NC_GIT ]] && $QBL_ALIVE; then
    QBL_ALIVE=false
    echo -e '\e[1;31mq_bashline died\e[0m'
fi


# If inside git repo
if [[ -d .git ]] || git rev-parse 2>/dev/null; then

    # Get current branch name or commit sha if detached
    head_info=$(git branch --show-current)
    if [[ -z "$head_info" ]]; then
        head_info=$(git rev-parse --short HEAD)
    fi
    printf -v GIT_REV "▕ ${C_BRA_F}${head_info}${C_GEN_F}"

    # If coproc still alive
    if [[ -n $CO_NC_GIT ]]; then
        # Sends cwd to git_lineutils
        pwd -P >&${CO_NC_GIT[1]}
        # Get only the latest output produced by git linetuils
        if [[ $QBL_ASYNC == true ]]; then
            sleep $QBL_SLEEP # Unnoticeable, "long" enough to give time to git_lineutils to process its things, usually
            while read -t 0; do # While there's buffered data in the pipe
                read -r REPO_INFO <&${CO_NC_GIT[0]}
            done <&${CO_NC_GIT[0]}
        else
            read -r REPO_INFO <&${CO_NC_GIT[0]}
        fi
    fi
fi

printf -v _exit "${C_EXT_F}${exit_code}${C_GEN_F}"
printf -v _cwd "▕ ${C_CWD_F}\w${C_GEN_F}"

# if inside nnn
[ -n "$NNNLVL" ] && printf -v _nnn "▕ ${C_NNN_F}n${NNNLVL}${C_GEN_F}"

printf -v PS1 "${C_GEN_T}${C_GEN_B}${_exit}${_nnn}${_cwd}${GIT_REV}${REPO_INFO}${C_GEN_T}${C_STP} "
printf "\e]0 $(basename $PWD)" # Updates window title
